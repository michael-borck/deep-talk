# AI Prompt Management System

## Table of Contents
1. [Overview](#overview)
2. [Core Architecture](#core-architecture)
3. [Template Engine & Variable System](#template-engine--variable-system)
4. [Category & Type Organization](#category--type-organization)
5. [Default vs Custom Prompt Management](#default-vs-custom-prompt-management)
6. [Model Compatibility Framework](#model-compatibility-framework)
7. [System Usage Tracking](#system-usage-tracking)
8. [Service Integration](#service-integration)
9. [Configuration Workflows](#configuration-workflows)
10. [Database Operations](#database-operations)
11. [Error Handling & Fallbacks](#error-handling--fallbacks)
12. [API Reference](#api-reference)
13. [Implementation Patterns](#implementation-patterns)
14. [Best Practices](#best-practices)

## Overview

Audio-Scribe implements a sophisticated AI Prompt Management System that enables dynamic customization of AI interactions across different processing stages. The system provides template-based prompts with variable substitution, category-based organization, model compatibility awareness, and robust fallback mechanisms.

### Key Features

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    AI Prompt Management System                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Template Engine    â”‚  Category System    â”‚  Model Compatibilityâ”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Variable    â”‚   â”‚  â”‚ Chat        â”‚   â”‚  â”‚ Universal   â”‚    â”‚
â”‚  â”‚ Substitutionâ”‚   â”‚  â”‚ Analysis    â”‚   â”‚  â”‚ Model-      â”‚    â”‚
â”‚  â”‚ Validation  â”‚   â”‚  â”‚ Speaker     â”‚   â”‚  â”‚ Specific    â”‚    â”‚
â”‚  â”‚ Processing  â”‚   â”‚  â”‚ Validation  â”‚   â”‚  â”‚ Warnings    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Default Management â”‚  System Integration â”‚  Export/Import     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Built-in    â”‚   â”‚  â”‚ File        â”‚   â”‚  â”‚ Backup      â”‚    â”‚
â”‚  â”‚ Prompts     â”‚   â”‚  â”‚ Processor   â”‚   â”‚  â”‚ Sharing     â”‚    â”‚
â”‚  â”‚ Reset       â”‚   â”‚  â”‚ Chat        â”‚   â”‚  â”‚ Migration   â”‚    â”‚
â”‚  â”‚ Capability  â”‚   â”‚  â”‚ Service     â”‚   â”‚  â”‚ Templates   â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Benefits for AI Applications

- **Flexibility**: Dynamic prompt customization without code changes
- **Consistency**: Centralized prompt management across application features
- **Scalability**: Category-based organization supports growing AI capabilities
- **Reliability**: Multi-layer fallback system ensures application stability
- **User Control**: Interface for customizing AI behavior while preserving system integrity

## Core Architecture

### Service-Oriented Design

The system follows a clean service-oriented architecture with clear separation of concerns:

```typescript
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   PromptService  â”‚    â”‚  PromptsSettings    â”‚    â”‚  PromptEditor   â”‚
â”‚                  â”‚    â”‚                     â”‚    â”‚                 â”‚
â”‚ â€¢ Template Eng.  â”‚â—„â”€â”€â–ºâ”‚ â€¢ Category Nav      â”‚â—„â”€â”€â–ºâ”‚ â€¢ Variable Ed.  â”‚
â”‚ â€¢ CRUD Ops       â”‚    â”‚ â€¢ Search/Filter     â”‚    â”‚ â€¢ Token Count   â”‚
â”‚ â€¢ Fallbacks      â”‚    â”‚ â€¢ Import/Export     â”‚    â”‚ â€¢ Reset Feature â”‚
â”‚ â€¢ Integration    â”‚    â”‚ â€¢ Usage Indicators  â”‚    â”‚ â€¢ Validation    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                          â”‚                          â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚        Database Layer       â”‚
                    â”‚                             â”‚
                    â”‚ â€¢ SQLite Storage            â”‚
                    â”‚ â€¢ Indexed Queries           â”‚
                    â”‚ â€¢ IPC Communication         â”‚
                    â”‚ â€¢ JSON Metadata             â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Core Components

#### 1. PromptService (`src/services/promptService.ts`)

**Purpose**: Central business logic for prompt operations and template processing

```typescript
export class PromptService {
  private static instance: PromptService;
  
  // Primary API for other services
  async getProcessedPrompt(
    category: string, 
    type: string, 
    variables: Record<string, string>
  ): Promise<string>
  
  // CRUD operations
  async getPrompt(category: string, type: string): Promise<AIPrompt | null>
  async savePrompt(prompt: AIPrompt): Promise<void>
  async deletePrompt(id: string): Promise<void>
  
  // Template processing
  replaceVariables(promptText: string, variables: Record<string, string>): string
  extractVariables(promptText: string): string[]
  
  // Default management
  getDefaultPrompt(category: string, type: string): AIPrompt | null
  getDefaultPrompts(): Record<string, Record<string, AIPrompt>>
  
  // Utility methods
  validatePrompt(prompt: AIPrompt): ValidationResult
  estimateTokens(text: string): number
}
```

**Key Features**:
- Singleton pattern for state consistency
- Template engine with variable substitution
- Fallback to defaults when custom prompts fail
- Integration with database via Electron IPC

#### 2. PromptsSettings (`src/components/PromptsSettings.tsx`)

**Purpose**: Main configuration interface for prompt management

```typescript
interface PromptsSettingsProps {
  // No props - self-contained configuration component
}

interface PromptsSettingsState {
  activeCategory: PromptCategory;
  searchTerm: string;
  prompts: Record<string, AIPrompt[]>;
  loading: boolean;
  showEditor: boolean;
  selectedPrompt: AIPrompt | null;
}
```

**Features**:
- Category-based navigation (tabs for Chat, Analysis, Speaker, Validation)
- Real-time search and filtering
- System usage indicators (shows which prompts are actively used)
- Import/Export functionality for backup and sharing
- Responsive design with clear visual hierarchy

#### 3. PromptEditor (`src/components/PromptEditor.tsx`)

**Purpose**: Individual prompt editing interface with advanced features

```typescript
interface PromptEditorProps {
  prompt: AIPrompt;
  isOpen: boolean;
  onClose: () => void;
  onSave: (prompt: AIPrompt) => void;
}

interface PromptEditorState {
  promptText: string;
  variables: string[];
  tokenCount: number;
  validationErrors: string[];
  hasChanges: boolean;
}
```

**Features**:
- Variable extraction and highlighting (`{variable}` patterns)
- Token counting with optimization hints
- Model compatibility warnings
- Reset to default functionality
- Real-time validation

### Database Schema

```sql
CREATE TABLE ai_prompts (
  id TEXT PRIMARY KEY,
  category TEXT NOT NULL,                    -- 'chat', 'analysis', 'speaker', 'validation'
  type TEXT NOT NULL,                        -- Specific prompt purpose
  name TEXT NOT NULL,                        -- Human-readable name
  description TEXT,                          -- Usage explanation
  prompt_text TEXT NOT NULL,                 -- Template content
  variables TEXT,                            -- JSON array of variables
  model_compatibility TEXT DEFAULT 'all',    -- JSON array or 'all'
  is_default BOOLEAN DEFAULT 0,             -- System vs user prompt
  system_used BOOLEAN DEFAULT 0,            -- Active in processing pipeline
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  UNIQUE(category, type)                     -- Prevent duplicates
);

-- Performance indexes
CREATE INDEX idx_ai_prompts_category ON ai_prompts(category);
CREATE INDEX idx_ai_prompts_type ON ai_prompts(type);
CREATE INDEX idx_ai_prompts_category_type ON ai_prompts(category, type);
CREATE INDEX idx_ai_prompts_system_used ON ai_prompts(system_used);
```

## Template Engine & Variable System

### Variable Substitution Engine

The template engine uses a simple but powerful variable substitution system:

```typescript
class TemplateEngine {
  /**
   * Replace template variables with actual values
   * Variables follow the pattern: {variable_name}
   */
  replaceVariables(promptText: string, variables: Record<string, string>): string {
    let result = promptText;
    
    for (const [key, value] of Object.entries(variables)) {
      const regex = new RegExp(`\\{${key}\\}`, 'g');
      result = result.replace(regex, value || '');
    }
    
    // Log any unreplaced variables for debugging
    const remainingVars = this.extractVariables(result);
    if (remainingVars.length > 0) {
      console.warn('Unreplaced variables found:', remainingVars);
    }
    
    return result;
  }
  
  /**
   * Extract all variables from a prompt template
   */
  extractVariables(promptText: string): string[] {
    const regex = /\{([^}]+)\}/g;
    const variables: string[] = [];
    let match;
    
    while ((match = regex.exec(promptText)) !== null) {
      if (!variables.includes(match[1])) {
        variables.push(match[1]);
      }
    }
    
    return variables;
  }
}
```

### Variable Types and Usage

#### **Standard Variables**

```typescript
// Common variables across all prompts
interface StandardVariables {
  transcript: string;        // Full transcript text
  title: string;            // Transcript title
  context: string;          // Relevant chunks or excerpts
  message: string;          // User question or input
  options: string;          // Processing options
  metadata: string;         // Transcript metadata
}
```

#### **Context-Specific Variables**

```typescript
// Chat-specific variables
interface ChatVariables extends StandardVariables {
  conversation_history: string;  // Previous messages
  memory_summary: string;        // Compacted conversation
  user_name: string;            // User identifier
}

// Analysis-specific variables
interface AnalysisVariables extends StandardVariables {
  analysis_type: string;        // Type of analysis requested
  previous_analysis: string;    // Prior analysis results
  focus_areas: string;          // Specific areas to analyze
}
```

### Template Examples

#### **Basic Analysis Template**
```typescript
const basicAnalysisTemplate = `You are an AI assistant analyzing a transcript. Please provide a comprehensive analysis of the following content.

Transcript Title: {title}
Content: {transcript}

Please provide your analysis in the following JSON format:
{
  "summary": "Brief summary of the main points",
  "key_topics": ["topic1", "topic2", "topic3"],
  "action_items": ["action1", "action2"],
  "insights": ["insight1", "insight2"]
}

Focus on accuracy and relevance. Ensure all responses are based solely on the provided content.`;
```

#### **Chat Template with Context**
```typescript
const chatTemplate = `You are a helpful AI assistant that answers questions about audio transcripts. 

Transcript: "{title}"
Relevant Context: {context}

Previous conversation summary: {memory_summary}

User Question: {message}

Please provide a helpful, accurate response based on the transcript content. If the question cannot be answered from the provided context, say so clearly.

Response:`;
```

#### **Speaker Detection Template**
```typescript
const speakerDetectionTemplate = `Analyze this transcript to detect the number of distinct speakers.

Transcript: {transcript}

Consider:
- Different speaking patterns and vocabulary
- Conversation flow and turn-taking
- Voice or tone indicators in the text
- Context clues about participants

Provide your analysis as a JSON object:
{
  "speaker_count": number,
  "confidence": "high|medium|low",
  "reasoning": "explanation of how you determined the count"
}`;
```

### Variable Validation

```typescript
interface VariableValidation {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  requiredVariables: string[];
  providedVariables: string[];
  missingVariables: string[];
}

class PromptValidator {
  validatePromptVariables(
    promptText: string, 
    providedVariables: Record<string, string>
  ): VariableValidation {
    const requiredVariables = this.extractVariables(promptText);
    const providedKeys = Object.keys(providedVariables);
    const missingVariables = requiredVariables.filter(
      variable => !providedKeys.includes(variable)
    );
    
    return {
      isValid: missingVariables.length === 0,
      errors: missingVariables.map(v => `Missing required variable: {${v}}`),
      warnings: this.checkVariableUsage(promptText, providedVariables),
      requiredVariables,
      providedVariables: providedKeys,
      missingVariables
    };
  }
  
  private checkVariableUsage(
    promptText: string, 
    variables: Record<string, string>
  ): string[] {
    const warnings: string[] = [];
    
    // Check for very long variable values
    Object.entries(variables).forEach(([key, value]) => {
      if (value.length > 10000) {
        warnings.push(`Variable {${key}} is very long (${value.length} chars) - consider truncation`);
      }
    });
    
    // Check for empty variables
    Object.entries(variables).forEach(([key, value]) => {
      if (!value.trim()) {
        warnings.push(`Variable {${key}} is empty or whitespace only`);
      }
    });
    
    return warnings;
  }
}
```

## Category & Type Organization

### Four-Tier Classification System

The prompt system organizes prompts using a hierarchical category and type structure:

#### **1. Chat Category (`'chat'`)**

Used for conversational AI interactions and memory management.

```typescript
const chatPrompts = {
  transcript_chat: {
    name: "Transcript Chat",
    description: "Primary prompt for conversing about transcript content",
    systemUsed: true,
    variables: ['title', 'context', 'memory_summary', 'message'],
    modelCompatibility: 'all'
  },
  
  conversation_compaction: {
    name: "Conversation Memory Compaction", 
    description: "Summarizes long conversations for memory management",
    systemUsed: true,
    variables: ['conversation_history', 'exchange_count'],
    modelCompatibility: 'all'
  }
};
```

#### **2. Analysis Category (`'analysis'`)**

Covers all AI-powered content analysis operations.

```typescript
const analysisPrompts = {
  basic_analysis: {
    name: "Basic Analysis",
    description: "Extract summary, topics, and action items",
    systemUsed: true,
    variables: ['transcript', 'title'],
    modelCompatibility: 'all'
  },
  
  sentiment_analysis: {
    name: "Sentiment Analysis",
    description: "Analyze emotional tone and sentiment",
    systemUsed: true,
    variables: ['transcript', 'title'],
    modelCompatibility: 'all'
  },
  
  emotion_analysis: {
    name: "Emotion Analysis", 
    description: "Detailed emotion detection and scoring",
    systemUsed: true,
    variables: ['transcript', 'title'],
    modelCompatibility: ['llama3', 'gpt-4', 'claude'] // Requires advanced models
  },
  
  research_analysis: {
    name: "Research Analysis",
    description: "Extract quotes, themes, Q&A pairs for research purposes", 
    systemUsed: true,
    variables: ['transcript', 'title', 'focus_areas'],
    modelCompatibility: ['llama3', 'gpt-4', 'claude'] // Complex analysis
  }
};
```

#### **3. Speaker Category (`'speaker'`)**

Handles speaker detection and segmentation tasks.

```typescript
const speakerPrompts = {
  speaker_count: {
    name: "Speaker Count Detection",
    description: "Determine the number of distinct speakers",
    systemUsed: true,
    variables: ['transcript'],
    modelCompatibility: 'all'
  },
  
  speaker_tagging: {
    name: "Speaker Tagging",
    description: "Assign text segments to specific speakers",
    systemUsed: true,
    variables: ['transcript', 'speaker_count', 'speaker_names'],
    modelCompatibility: ['llama3', 'gpt-4', 'claude'] // Requires reasoning
  }
};
```

#### **4. Validation Category (`'validation'`)**

Used for transcript correction and quality improvement.

```typescript
const validationPrompts = {
  transcript_validation: {
    name: "Transcript Validation",
    description: "Correct grammar, spelling, and punctuation errors",
    systemUsed: true,
    variables: ['transcript', 'validation_options'],
    modelCompatibility: 'all'
  }
};
```

### Hierarchical Retrieval Logic

```typescript
class PromptHierarchy {
  async getPrompt(category: string, type: string): Promise<AIPrompt | null> {
    // 1. Try user customization first
    const userPrompt = await this.getUserPrompt(category, type);
    if (userPrompt) {
      return userPrompt;
    }
    
    // 2. Fall back to system default
    const defaultPrompt = this.getDefaultPrompt(category, type);
    if (defaultPrompt) {
      return defaultPrompt;
    }
    
    // 3. Try category-level fallback
    const categoryFallback = this.getCategoryFallback(category);
    if (categoryFallback) {
      return categoryFallback;
    }
    
    // 4. Ultimate fallback
    return this.getUltimateFallback();
  }
  
  private async getUserPrompt(category: string, type: string): Promise<AIPrompt | null> {
    try {
      return await window.electronAPI.aiPrompts.get({ category, type });
    } catch (error) {
      console.warn(`Failed to retrieve user prompt ${category}:${type}`, error);
      return null;
    }
  }
  
  private getDefaultPrompt(category: string, type: string): AIPrompt | null {
    return this.defaultPrompts[category]?.[type] || null;
  }
  
  private getCategoryFallback(category: string): AIPrompt | null {
    // Each category has a generic fallback prompt
    const fallbacks = {
      chat: this.createGenericChatPrompt(),
      analysis: this.createGenericAnalysisPrompt(),
      speaker: this.createGenericSpeakerPrompt(),
      validation: this.createGenericValidationPrompt()
    };
    
    return fallbacks[category] || null;
  }
  
  private getUltimateFallback(): AIPrompt {
    return {
      id: 'ultimate_fallback',
      category: 'generic',
      type: 'fallback',
      name: 'Emergency Fallback',
      promptText: 'Please process the following content: {transcript}',
      variables: ['transcript'],
      modelCompatibility: 'all',
      systemUsed: false
    };
  }
}
```

## Default vs Custom Prompt Management

### Default Prompt System

#### **Built-in Prompts**

Default prompts are embedded directly in the service code to ensure system functionality even with empty databases:

```typescript
class DefaultPromptRegistry {
  private static defaultPrompts: Record<string, Record<string, AIPrompt>> = {
    chat: {
      transcript_chat: {
        id: 'default_transcript_chat',
        category: 'chat',
        type: 'transcript_chat',
        name: 'Transcript Chat',
        description: 'Default prompt for chatting about transcript content',
        promptText: `You are a helpful AI assistant that answers questions about audio transcripts.

Transcript: "{title}"
Relevant Context: {context}

Previous conversation: {memory_summary}

User Question: {message}

Please provide a helpful, accurate response based on the transcript content. If the question cannot be answered from the provided context, say so clearly.`,
        variables: ['title', 'context', 'memory_summary', 'message'],
        modelCompatibility: 'all',
        isDefault: true,
        systemUsed: true,
        created_at: '2024-01-01T00:00:00.000Z',
        updated_at: '2024-01-01T00:00:00.000Z'
      }
      // ... more default prompts
    },
    
    analysis: {
      basic_analysis: {
        id: 'default_basic_analysis',
        category: 'analysis', 
        type: 'basic_analysis',
        name: 'Basic Analysis',
        description: 'Extract summary, key topics, and action items',
        promptText: `Please analyze this transcript and provide a comprehensive summary.

Transcript Title: {title}
Content: {transcript}

Please provide your analysis in the following JSON format:
{
  "summary": "A concise summary of the main points discussed",
  "key_topics": ["topic1", "topic2", "topic3"],
  "action_items": ["action1", "action2", "action3"],
  "key_insights": ["insight1", "insight2"]
}

Focus on accuracy and ensure all responses are based solely on the provided content.`,
        variables: ['title', 'transcript'],
        modelCompatibility: 'all',
        isDefault: true,
        systemUsed: true,
        created_at: '2024-01-01T00:00:00.000Z',
        updated_at: '2024-01-01T00:00:00.000Z'
      }
      // ... more analysis prompts  
    }
    // ... other categories
  };
  
  static getDefault(category: string, type: string): AIPrompt | null {
    return this.defaultPrompts[category]?.[type] || null;
  }
  
  static getAllDefaults(): Record<string, Record<string, AIPrompt>> {
    return JSON.parse(JSON.stringify(this.defaultPrompts)); // Deep copy
  }
}
```

#### **System Usage Indicators**

```typescript
interface SystemUsageTracking {
  systemUsed: boolean;           // Is this prompt actively used by the system?
  lastUsed?: string;            // When was it last used?
  usageCount?: number;          // How many times has it been used?
  criticalToSystem: boolean;    // Is the system dependent on this prompt?
}

// Visual indicators in UI
const getSystemUsageIndicator = (prompt: AIPrompt) => {
  if (prompt.systemUsed) {
    return {
      badge: 'ğŸ”§ System Used',
      color: 'blue',
      tooltip: 'This prompt is actively used by the system for processing'
    };
  }
  
  return {
    badge: 'ğŸ“‹ Available',
    color: 'gray', 
    tooltip: 'This prompt is available for manual use'
  };
};
```

### Customization Workflow

#### **1. Discovery and Browsing**

```typescript
// Users browse prompts with full context
interface PromptDisplayInfo {
  prompt: AIPrompt;
  defaultVersion?: AIPrompt;    // Show comparison with default
  usageStats: {
    isSystemUsed: boolean;
    lastModified?: string;
    isCustomized: boolean;
  };
  validationStatus: {
    hasErrors: boolean;
    warnings: string[];
    tokenCount: number;
  };
}
```

#### **2. Editing Interface**

```typescript
class PromptEditor {
  state = {
    promptText: '',
    originalPrompt: null,
    hasChanges: false,
    variables: [],
    validationErrors: [],
    tokenCount: 0
  };
  
  handlePromptTextChange = (newText: string) => {
    this.setState({
      promptText: newText,
      hasChanges: newText !== this.state.originalPrompt?.promptText,
      variables: this.extractVariables(newText),
      validationErrors: this.validatePrompt(newText),
      tokenCount: this.estimateTokens(newText)
    });
  };
  
  handleSave = async () => {
    if (this.state.validationErrors.length > 0) {
      throw new Error('Cannot save prompt with validation errors');
    }
    
    const updatedPrompt = {
      ...this.state.originalPrompt,
      promptText: this.state.promptText,
      variables: JSON.stringify(this.state.variables),
      userModified: true,
      updated_at: new Date().toISOString()
    };
    
    await promptService.savePrompt(updatedPrompt);
  };
  
  handleReset = async () => {
    const defaultPrompt = promptService.getDefaultPrompt(
      this.state.originalPrompt.category,
      this.state.originalPrompt.type
    );
    
    if (defaultPrompt) {
      await promptService.resetToDefault(
        this.state.originalPrompt.category,
        this.state.originalPrompt.type
      );
      this.loadPrompt(defaultPrompt);
    }
  };
}
```

#### **3. Version Management**

```typescript
interface PromptVersion {
  id: string;
  promptId: string;
  version: number;
  promptText: string;
  changedBy: 'user' | 'system' | 'import';
  changeReason: string;
  created_at: string;
}

class PromptVersioning {
  async savePromptWithVersion(prompt: AIPrompt, changeReason: string): Promise<void> {
    // Create version record
    const version: PromptVersion = {
      id: generateId(),
      promptId: prompt.id,
      version: await this.getNextVersion(prompt.id),
      promptText: prompt.promptText,
      changedBy: 'user',
      changeReason,
      created_at: new Date().toISOString()
    };
    
    // Save both prompt and version
    await Promise.all([
      this.savePrompt(prompt),
      this.saveVersion(version)
    ]);
  }
  
  async getPromptHistory(promptId: string): Promise<PromptVersion[]> {
    return await window.electronAPI.database.all(
      'SELECT * FROM prompt_versions WHERE prompt_id = ? ORDER BY version DESC',
      [promptId]
    );
  }
  
  async revertToVersion(promptId: string, version: number): Promise<void> {
    const targetVersion = await this.getVersion(promptId, version);
    if (!targetVersion) {
      throw new Error(`Version ${version} not found for prompt ${promptId}`);
    }
    
    const currentPrompt = await this.getPrompt(promptId);
    const revertedPrompt = {
      ...currentPrompt,
      promptText: targetVersion.promptText,
      updated_at: new Date().toISOString()
    };
    
    await this.savePromptWithVersion(revertedPrompt, `Reverted to version ${version}`);
  }
}
```

## Model Compatibility Framework

### Compatibility Classification

The system categorizes prompts based on model requirements:

```typescript
interface ModelCompatibility {
  // Universal compatibility - works with any model
  universal: 'all';
  
  // Specific model support
  specific: string[];  // e.g., ['llama3', 'gpt-4', 'claude']
  
  // Minimum requirements  
  requirements: {
    minContextLength?: number;      // Minimum context window
    capabilities?: ModelCapability[];  // Required capabilities
    modelSize?: 'small' | 'medium' | 'large';
  };
}

enum ModelCapability {
  REASONING = 'reasoning',           // Complex logical reasoning
  JSON_OUTPUT = 'json_output',       // Structured JSON responses
  LONG_CONTEXT = 'long_context',     // Extended context handling
  CONVERSATION = 'conversation',     // Multi-turn conversations
  ANALYSIS = 'analysis'              // Content analysis tasks
}
```

### Model-Specific Optimizations

```typescript
class ModelCompatibilityManager {
  private modelProfiles = {
    'llama3': {
      contextLength: 8192,
      capabilities: [
        ModelCapability.REASONING,
        ModelCapability.JSON_OUTPUT,
        ModelCapability.CONVERSATION,
        ModelCapability.ANALYSIS
      ],
      size: 'large',
      strengths: ['reasoning', 'conversation'],
      limitations: ['context_length']
    },
    
    'llama2': {
      contextLength: 4096,
      capabilities: [
        ModelCapability.CONVERSATION,
        ModelCapability.ANALYSIS
      ],
      size: 'medium',
      strengths: ['conversation'],
      limitations: ['reasoning', 'json_output', 'context_length']
    },
    
    'gpt-4': {
      contextLength: 32768,
      capabilities: Object.values(ModelCapability),
      size: 'large',
      strengths: ['reasoning', 'json_output', 'long_context'],
      limitations: []
    }
  };
  
  validatePromptCompatibility(
    prompt: AIPrompt, 
    targetModel: string
  ): CompatibilityResult {
    const modelProfile = this.modelProfiles[targetModel];
    if (!modelProfile) {
      return {
        compatible: false,
        warnings: [`Unknown model: ${targetModel}`],
        recommendations: ['Use a known model or set compatibility to "all"']
      };
    }
    
    // Check if prompt is compatible
    if (prompt.modelCompatibility === 'all') {
      return { compatible: true, warnings: [], recommendations: [] };
    }
    
    if (Array.isArray(prompt.modelCompatibility)) {
      const isSupported = prompt.modelCompatibility.includes(targetModel);
      if (!isSupported) {
        return {
          compatible: false,
          warnings: [`Prompt not optimized for ${targetModel}`],
          recommendations: [
            'Consider using a compatible model',
            'Test prompt performance carefully',
            'Modify prompt for better compatibility'
          ]
        };
      }
    }
    
    // Check specific requirements
    const requirements = prompt.requirements || {};
    const warnings: string[] = [];
    const recommendations: string[] = [];
    
    if (requirements.minContextLength && 
        modelProfile.contextLength < requirements.minContextLength) {
      warnings.push(
        `Model context length (${modelProfile.contextLength}) may be insufficient (requires ${requirements.minContextLength})`
      );
      recommendations.push('Consider truncating prompt or using a larger model');
    }
    
    if (requirements.capabilities) {
      const missingCapabilities = requirements.capabilities.filter(
        cap => !modelProfile.capabilities.includes(cap)
      );
      
      if (missingCapabilities.length > 0) {
        warnings.push(`Model may lack required capabilities: ${missingCapabilities.join(', ')}`);
        recommendations.push('Test prompt carefully or use a more capable model');
      }
    }
    
    return {
      compatible: warnings.length === 0,
      warnings,
      recommendations
    };
  }
  
  suggestOptimizations(prompt: AIPrompt, targetModel: string): OptimizationSuggestion[] {
    const modelProfile = this.modelProfiles[targetModel];
    const suggestions: OptimizationSuggestion[] = [];
    
    // Context length optimization
    const estimatedTokens = this.estimateTokens(prompt.promptText);
    if (estimatedTokens > modelProfile.contextLength * 0.8) {
      suggestions.push({
        type: 'context_optimization',
        description: 'Prompt may be too long for model context window',
        suggestion: 'Consider shortening the prompt or splitting into multiple requests',
        priority: 'high'
      });
    }
    
    // Model-specific optimizations
    if (modelProfile.limitations.includes('json_output') && 
        prompt.promptText.includes('JSON')) {
      suggestions.push({
        type: 'output_format',
        description: 'Model may struggle with JSON output format',
        suggestion: 'Consider using plain text output with clear structure',
        priority: 'medium'
      });
    }
    
    if (modelProfile.limitations.includes('reasoning') && 
        this.requiresComplexReasoning(prompt.promptText)) {
      suggestions.push({
        type: 'complexity_reduction',
        description: 'Prompt requires complex reasoning that may challenge this model',
        suggestion: 'Break down the task into simpler steps or use explicit instructions',
        priority: 'high'
      });
    }
    
    return suggestions;
  }
}
```

### UI Integration

```typescript
// Compatibility warnings in the UI
const CompatibilityIndicator: React.FC<{
  prompt: AIPrompt;
  currentModel: string;
}> = ({ prompt, currentModel }) => {
  const compatibility = useCompatibilityCheck(prompt, currentModel);
  
  if (compatibility.compatible) {
    return (
      <div className="flex items-center text-green-600">
        <CheckIcon className="w-4 h-4 mr-1" />
        Compatible with {currentModel}
      </div>
    );
  }
  
  return (
    <div className="border-l-4 border-yellow-400 bg-yellow-50 p-4 rounded">
      <div className="flex items-center text-yellow-800 mb-2">
        <WarningIcon className="w-4 h-4 mr-1" />
        Compatibility Warning
      </div>
      
      <ul className="text-sm text-yellow-700 space-y-1">
        {compatibility.warnings.map((warning, index) => (
          <li key={index}>â€¢ {warning}</li>
        ))}
      </ul>
      
      {compatibility.recommendations.length > 0 && (
        <div className="mt-3">
          <div className="text-sm font-medium text-yellow-800 mb-1">
            Recommendations:
          </div>
          <ul className="text-sm text-yellow-700 space-y-1">
            {compatibility.recommendations.map((rec, index) => (
              <li key={index}>â€¢ {rec}</li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
};
```

## System Usage Tracking

### Usage Classification System

The system tracks how prompts are used throughout the application:

```typescript
interface SystemUsageMetadata {
  systemUsed: boolean;              // Actively used by system processes
  criticalToSystem: boolean;        // System depends on this prompt
  usageFrequency: 'high' | 'medium' | 'low';
  lastUsed?: string;               // Timestamp of last usage
  usageCount: number;              // Total usage count
  usageContexts: UsageContext[];   // Where/how it's used
}

interface UsageContext {
  service: string;                 // Service that uses this prompt
  method: string;                  // Specific method or function
  frequency: number;               // Usage frequency in this context
  essential: boolean;              // Is it essential for this context?
}
```

### Integration Points Tracking

```typescript
class SystemUsageTracker {
  private usageMap = new Map<string, UsageMetadata>();
  
  // Track usage when prompts are retrieved
  async trackPromptUsage(
    category: string, 
    type: string, 
    context: UsageContext
  ): Promise<void> {
    const key = `${category}:${type}`;
    const existing = this.usageMap.get(key) || {
      usageCount: 0,
      contexts: [],
      lastUsed: null
    };
    
    existing.usageCount += 1;
    existing.lastUsed = new Date().toISOString();
    
    // Update or add context
    const contextIndex = existing.contexts.findIndex(
      c => c.service === context.service && c.method === context.method
    );
    
    if (contextIndex >= 0) {
      existing.contexts[contextIndex].frequency += 1;
    } else {
      existing.contexts.push({ ...context, frequency: 1 });
    }
    
    this.usageMap.set(key, existing);
    
    // Periodically persist to database
    if (existing.usageCount % 10 === 0) {
      await this.persistUsageData(key, existing);
    }
  }
  
  // Get usage statistics for UI display
  getUsageStats(category: string, type: string): UsageStatistics {
    const key = `${category}:${type}`;
    const usage = this.usageMap.get(key);
    
    if (!usage) {
      return {
        isSystemUsed: false,
        usageFrequency: 'none',
        lastUsed: null,
        primaryContexts: []
      };
    }
    
    const frequency = this.calculateFrequency(usage.usageCount);
    const primaryContexts = usage.contexts
      .sort((a, b) => b.frequency - a.frequency)
      .slice(0, 3);
    
    return {
      isSystemUsed: usage.usageCount > 0,
      usageFrequency: frequency,
      lastUsed: usage.lastUsed,
      primaryContexts
    };
  }
  
  private calculateFrequency(count: number): 'high' | 'medium' | 'low' | 'none' {
    if (count === 0) return 'none';
    if (count > 100) return 'high';
    if (count > 10) return 'medium';
    return 'low';
  }
}
```

### Critical System Prompts

```typescript
// Prompts essential for system operation
const CRITICAL_PROMPTS = {
  'analysis:basic_analysis': {
    description: 'Core analysis functionality',
    failureImpact: 'Transcript processing will fail',
    fallbackAvailable: true
  },
  
  'chat:transcript_chat': {
    description: 'Primary chat functionality',
    failureImpact: 'Chat system will not work',
    fallbackAvailable: true
  },
  
  'validation:transcript_validation': {
    description: 'Transcript quality improvement',
    failureImpact: 'Validation stage will be skipped',
    fallbackAvailable: false
  }
};

class CriticalPromptManager {
  validateCriticalPrompts(): ValidationReport {
    const report: ValidationReport = {
      allCriticalPromptsValid: true,
      issues: [],
      recommendations: []
    };
    
    for (const [promptKey, metadata] of Object.entries(CRITICAL_PROMPTS)) {
      const [category, type] = promptKey.split(':');
      const prompt = promptService.getPrompt(category, type);
      
      if (!prompt) {
        report.allCriticalPromptsValid = false;
        report.issues.push({
          promptKey,
          severity: 'error',
          message: `Critical prompt missing: ${metadata.description}`,
          impact: metadata.failureImpact
        });
        
        if (metadata.fallbackAvailable) {
          report.recommendations.push(
            `Reset ${promptKey} to default to restore functionality`
          );
        }
      } else {
        // Validate prompt integrity
        const validation = this.validatePromptIntegrity(prompt);
        if (!validation.isValid) {
          report.allCriticalPromptsValid = false;
          report.issues.push({
            promptKey,
            severity: 'warning',
            message: `Critical prompt has issues: ${validation.errors.join(', ')}`,
            impact: 'May cause processing failures'
          });
        }
      }
    }
    
    return report;
  }
  
  async repairCriticalPrompts(): Promise<RepairResult> {
    const repairActions: RepairAction[] = [];
    
    for (const [promptKey] of Object.entries(CRITICAL_PROMPTS)) {
      const [category, type] = promptKey.split(':');
      const prompt = await promptService.getPrompt(category, type);
      
      if (!prompt) {
        // Restore from default
        await promptService.resetToDefault(category, type);
        repairActions.push({
          promptKey,
          action: 'restored_default',
          success: true
        });
      }
    }
    
    return {
      repairActions,
      allRepairsSuccessful: repairActions.every(a => a.success)
    };
  }
}
```

## Service Integration

### FileProcessor Integration

The file processing pipeline heavily integrates with the prompt system for various analysis stages:

```typescript
class FileProcessor {
  async performBasicAnalysis(transcript: Transcript): Promise<AnalysisResult> {
    // Get analysis prompt with variables
    const analysisPrompt = await promptService.getProcessedPrompt(
      'analysis', 
      'basic_analysis', 
      {
        transcript: transcript.full_text || transcript.validated_text,
        title: transcript.title
      }
    );
    
    // Track usage
    await systemUsageTracker.trackPromptUsage('analysis', 'basic_analysis', {
      service: 'FileProcessor',
      method: 'performBasicAnalysis',
      essential: true
    });
    
    try {
      const response = await this.callAIService(analysisPrompt);
      return this.parseAnalysisResponse(response);
    } catch (error) {
      // Fallback with simpler prompt
      console.warn('Primary analysis failed, trying fallback:', error);
      return await this.performFallbackAnalysis(transcript);
    }
  }
  
  async performSentimentAnalysis(transcript: Transcript): Promise<SentimentResult> {
    const sentimentPrompt = await promptService.getProcessedPrompt(
      'analysis',
      'sentiment_analysis',
      {
        transcript: transcript.validated_text || transcript.full_text,
        title: transcript.title
      }
    );
    
    const response = await this.callAIService(sentimentPrompt);
    return this.parseSentimentResponse(response);
  }
  
  async performValidation(
    transcript: Transcript, 
    options: ValidationOptions
  ): Promise<ValidationResult> {
    const validationPrompt = await promptService.getProcessedPrompt(
      'validation',
      'transcript_validation',
      {
        transcript: transcript.full_text,
        validation_options: JSON.stringify(options)
      }
    );
    
    const response = await this.callAIService(validationPrompt);
    return this.parseValidationResponse(response);
  }
  
  private async performFallbackAnalysis(transcript: Transcript): Promise<AnalysisResult> {
    // Use hard-coded minimal prompt as ultimate fallback
    const fallbackPrompt = `Analyze this transcript and provide summary, topics, and action items in JSON format:

${transcript.full_text}

Response:`;
    
    const response = await this.callAIService(fallbackPrompt);
    return this.parseAnalysisResponse(response);
  }
}
```

### ChatService Integration

```typescript
class ChatService {
  async chatWithTranscript(
    transcriptId: string,
    conversationId: string,
    userMessage: string,
    conversationHistory: ChatMessage[]
  ): Promise<ChatMessage> {
    // Get transcript and build context
    const transcript = await this.getTranscript(transcriptId);
    const context = await this.buildContext(transcript, userMessage);
    const memory = await this.getConversationMemory(conversationId);
    
    // Get chat prompt with full context
    const chatPrompt = await promptService.getProcessedPrompt(
      'chat',
      'transcript_chat',
      {
        title: transcript.title,
        context: context.relevantChunks,
        memory_summary: memory?.compactedSummary || '',
        message: userMessage
      }
    );
    
    // Track system usage
    await systemUsageTracker.trackPromptUsage('chat', 'transcript_chat', {
      service: 'ChatService',
      method: 'chatWithTranscript',
      essential: true
    });
    
    const response = await this.callLLM(chatPrompt);
    
    return {
      id: Date.now(),
      conversation_id: conversationId,
      role: 'assistant',
      content: response,
      created_at: new Date().toISOString()
    };
  }
  
  async compactConversationMemory(
    conversationId: string,
    messages: ChatMessage[]
  ): Promise<string> {
    const compactionPrompt = await promptService.getProcessedPrompt(
      'chat',
      'conversation_compaction',
      {
        conversation_history: this.formatMessagesForCompaction(messages),
        exchange_count: messages.length.toString()
      }
    );
    
    const summary = await this.callLLM(compactionPrompt);
    return summary;
  }
}
```

### Dynamic Integration Registry

```typescript
class IntegrationRegistry {
  private integrations: Map<string, ServiceIntegration> = new Map();
  
  registerService(integration: ServiceIntegration): void {
    this.integrations.set(integration.serviceName, integration);
  }
  
  async notifyPromptChange(category: string, type: string): Promise<void> {
    const affectedServices = Array.from(this.integrations.values())
      .filter(integration => 
        integration.usedPrompts.some(p => 
          p.category === category && p.type === type
        )
      );
    
    // Notify services about prompt changes
    await Promise.all(
      affectedServices.map(service => 
        service.onPromptChanged?.(category, type)
      )
    );
  }
  
  getPromptUsage(category: string, type: string): ServiceUsage[] {
    const usage: ServiceUsage[] = [];
    
    for (const integration of this.integrations.values()) {
      const promptUsage = integration.usedPrompts.find(p => 
        p.category === category && p.type === type
      );
      
      if (promptUsage) {
        usage.push({
          serviceName: integration.serviceName,
          usage: promptUsage,
          critical: integration.criticalPrompts?.includes(`${category}:${type}`) || false
        });
      }
    }
    
    return usage;
  }
}

interface ServiceIntegration {
  serviceName: string;
  usedPrompts: PromptUsageInfo[];
  criticalPrompts?: string[];          // Prompts essential for service operation
  onPromptChanged?: (category: string, type: string) => Promise<void>;
}

interface PromptUsageInfo {
  category: string;
  type: string;
  method: string;                      // Method that uses this prompt
  frequency: 'high' | 'medium' | 'low';
  purpose: string;                     // Description of how it's used
}
```

## Configuration Workflows

### User Configuration Journey

#### **1. Discovery and Navigation**

```typescript
// Main configuration interface
const PromptsSettings: React.FC = () => {
  const [activeCategory, setActiveCategory] = useState<PromptCategory>('chat');
  const [searchTerm, setSearchTerm] = useState('');
  const [prompts, setPrompts] = useState<Record<string, AIPrompt[]>>({});
  
  const categories: PromptCategory[] = ['chat', 'analysis', 'speaker', 'validation'];
  
  const filteredPrompts = useMemo(() => {
    const categoryPrompts = prompts[activeCategory] || [];
    if (!searchTerm) return categoryPrompts;
    
    return categoryPrompts.filter(prompt =>
      prompt.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      prompt.description?.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [prompts, activeCategory, searchTerm]);
  
  return (
    <div className="space-y-6">
      {/* Category Navigation */}
      <div className="border-b border-gray-200">
        <nav className="flex space-x-8">
          {categories.map(category => (
            <button
              key={category}
              onClick={() => setActiveCategory(category)}
              className={`py-2 px-1 border-b-2 font-medium text-sm ${
                activeCategory === category
                  ? 'border-blue-500 text-blue-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700'
              }`}
            >
              {category.charAt(0).toUpperCase() + category.slice(1)}
            </button>
          ))}
        </nav>
      </div>
      
      {/* Search and Filter */}
      <div className="flex items-center gap-4">
        <div className="flex-1">
          <input
            type="text"
            placeholder="Search prompts..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-md"
          />
        </div>
        <PromptImportExport category={activeCategory} />
      </div>
      
      {/* Prompts List */}
      <div className="space-y-4">
        {filteredPrompts.map(prompt => (
          <PromptCard 
            key={prompt.id} 
            prompt={prompt}
            onEdit={() => openEditor(prompt)}
            onReset={() => resetPrompt(prompt)}
          />
        ))}
      </div>
    </div>
  );
};
```

#### **2. Individual Prompt Management**

```typescript
const PromptCard: React.FC<{
  prompt: AIPrompt;
  onEdit: () => void;
  onReset: () => void;
}> = ({ prompt, onEdit, onReset }) => {
  const usageStats = usePromptUsage(prompt.category, prompt.type);
  const compatibility = useModelCompatibility(prompt);
  
  return (
    <div className="border border-gray-200 rounded-lg p-6">
      {/* Header */}
      <div className="flex items-start justify-between mb-4">
        <div>
          <h3 className="text-lg font-medium text-gray-900">
            {prompt.name}
          </h3>
          <p className="text-sm text-gray-500 mt-1">
            {prompt.description}
          </p>
        </div>
        
        <div className="flex items-center gap-2">
          {/* System Usage Indicator */}
          {prompt.systemUsed && (
            <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">
              ğŸ”§ System Used
            </span>
          )}
          
          {/* Compatibility Warning */}
          {compatibility.hasWarnings && (
            <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800">
              âš ï¸ Check Compatibility
            </span>
          )}
        </div>
      </div>
      
      {/* Usage Statistics */}
      {usageStats.isSystemUsed && (
        <div className="mb-4 text-sm text-gray-600">
          <div className="flex items-center gap-4">
            <span>Usage: {usageStats.usageFrequency}</span>
            {usageStats.lastUsed && (
              <span>Last used: {formatRelativeTime(usageStats.lastUsed)}</span>
            )}
          </div>
          
          {usageStats.primaryContexts.length > 0 && (
            <div className="mt-2">
              <span className="font-medium">Used by: </span>
              {usageStats.primaryContexts.map(ctx => ctx.service).join(', ')}
            </div>
          )}
        </div>
      )}
      
      {/* Variables */}
      {prompt.variables && prompt.variables.length > 0 && (
        <div className="mb-4">
          <div className="text-sm font-medium text-gray-700 mb-2">Variables:</div>
          <div className="flex flex-wrap gap-2">
            {prompt.variables.map(variable => (
              <code key={variable} className="px-2 py-1 bg-gray-100 rounded text-sm">
                {`{${variable}}`}
              </code>
            ))}
          </div>
        </div>
      )}
      
      {/* Actions */}
      <div className="flex items-center justify-between">
        <div className="text-sm text-gray-500">
          {prompt.userModified 
            ? `Modified ${formatRelativeTime(prompt.updated_at)}`
            : 'Default prompt'
          }
        </div>
        
        <div className="flex gap-2">
          {prompt.userModified && (
            <button
              onClick={onReset}
              className="px-3 py-1 text-sm text-gray-600 hover:text-gray-900"
            >
              Reset to Default
            </button>
          )}
          <button
            onClick={onEdit}
            className="px-3 py-1 text-sm bg-blue-600 text-white rounded hover:bg-blue-700"
          >
            Edit
          </button>
        </div>
      </div>
    </div>
  );
};
```

#### **3. Advanced Editing Interface**

```typescript
const PromptEditor: React.FC<{
  prompt: AIPrompt;
  isOpen: boolean;
  onClose: () => void;
  onSave: (prompt: AIPrompt) => void;
}> = ({ prompt, isOpen, onClose, onSave }) => {
  const [promptText, setPromptText] = useState(prompt.promptText);
  const [variables, setVariables] = useState<string[]>([]);
  const [validationErrors, setValidationErrors] = useState<string[]>([]);
  const [tokenCount, setTokenCount] = useState(0);
  
  useEffect(() => {
    const extractedVars = extractVariables(promptText);
    const errors = validatePromptText(promptText);
    const tokens = estimateTokens(promptText);
    
    setVariables(extractedVars);
    setValidationErrors(errors);
    setTokenCount(tokens);
  }, [promptText]);
  
  const handleSave = async () => {
    if (validationErrors.length > 0) {
      alert('Please fix validation errors before saving');
      return;
    }
    
    const updatedPrompt = {
      ...prompt,
      promptText,
      variables: JSON.stringify(variables),
      userModified: true,
      updated_at: new Date().toISOString()
    };
    
    await onSave(updatedPrompt);
    onClose();
  };
  
  return (
    <Modal isOpen={isOpen} onClose={onClose} size="xl">
      <div className="space-y-6">
        {/* Header */}
        <div>
          <h2 className="text-xl font-semibold">Edit Prompt: {prompt.name}</h2>
          <p className="text-gray-600 mt-1">{prompt.description}</p>
        </div>
        
        {/* Prompt Text Editor */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Prompt Text
          </label>
          <textarea
            value={promptText}
            onChange={(e) => setPromptText(e.target.value)}
            rows={12}
            className="w-full px-3 py-2 border border-gray-300 rounded-md font-mono text-sm"
            placeholder="Enter your prompt text here..."
          />
          
          {/* Token Count */}
          <div className="mt-2 text-sm text-gray-500">
            Estimated tokens: {tokenCount}
            {tokenCount > 1000 && (
              <span className="text-yellow-600 ml-2">
                âš ï¸ Large prompt - consider optimization
              </span>
            )}
          </div>
        </div>
        
        {/* Variables */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Detected Variables
          </label>
          {variables.length > 0 ? (
            <div className="flex flex-wrap gap-2">
              {variables.map(variable => (
                <span
                  key={variable}
                  className="inline-flex items-center px-3 py-1 rounded-full text-sm bg-blue-100 text-blue-800"
                >
                  {`{${variable}}`}
                </span>
              ))}
            </div>
          ) : (
            <p className="text-gray-500 text-sm">No variables detected</p>
          )}
        </div>
        
        {/* Validation Errors */}
        {validationErrors.length > 0 && (
          <div className="border-l-4 border-red-400 bg-red-50 p-4 rounded">
            <div className="flex items-center text-red-800 mb-2">
              <span className="font-medium">Validation Errors:</span>
            </div>
            <ul className="text-sm text-red-700 space-y-1">
              {validationErrors.map((error, index) => (
                <li key={index}>â€¢ {error}</li>
              ))}
            </ul>
          </div>
        )}
        
        {/* Model Compatibility */}
        <ModelCompatibilityChecker prompt={{ ...prompt, promptText }} />
        
        {/* Actions */}
        <div className="flex justify-between">
          <button
            onClick={() => setPromptText(getDefaultPrompt(prompt.category, prompt.type)?.promptText || '')}
            className="px-4 py-2 text-gray-600 hover:text-gray-900"
          >
            Reset to Default
          </button>
          
          <div className="flex gap-3">
            <button
              onClick={onClose}
              className="px-4 py-2 text-gray-700 hover:bg-gray-100 rounded"
            >
              Cancel
            </button>
            <button
              onClick={handleSave}
              disabled={validationErrors.length > 0}
              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
            >
              Save Changes
            </button>
          </div>
        </div>
      </div>
    </Modal>
  );
};
```

### Import/Export System

```typescript
class PromptImportExport {
  async exportPrompts(category?: string): Promise<ExportData> {
    const prompts = category 
      ? await this.getPromptsByCategory(category)
      : await this.getAllPrompts();
    
    const exportData: ExportData = {
      version: '1.0',
      exportDate: new Date().toISOString(),
      metadata: {
        source: 'Audio-Scribe',
        promptCount: prompts.length,
        categories: [...new Set(prompts.map(p => p.category))]
      },
      prompts: this.groupPromptsByCategory(prompts)
    };
    
    return exportData;
  }
  
  async importPrompts(
    importData: ExportData, 
    options: ImportOptions
  ): Promise<ImportResult> {
    const result: ImportResult = {
      imported: 0,
      skipped: 0,
      errors: [],
      warnings: []
    };
    
    // Validate import data
    const validation = this.validateImportData(importData);
    if (!validation.isValid) {
      result.errors.push(...validation.errors);
      return result;
    }
    
    // Process prompts by category
    for (const [category, categoryPrompts] of Object.entries(importData.prompts)) {
      for (const prompt of categoryPrompts) {
        try {
          const importResult = await this.importSinglePrompt(prompt, options);
          
          if (importResult.imported) {
            result.imported++;
          } else {
            result.skipped++;
            if (importResult.reason) {
              result.warnings.push(`Skipped ${prompt.name}: ${importResult.reason}`);
            }
          }
        } catch (error) {
          result.errors.push(`Failed to import ${prompt.name}: ${error.message}`);
        }
      }
    }
    
    return result;
  }
  
  private async importSinglePrompt(
    prompt: AIPrompt, 
    options: ImportOptions
  ): Promise<SingleImportResult> {
    const existing = await promptService.getPrompt(prompt.category, prompt.type);
    
    if (existing) {
      if (options.overwriteExisting) {
        // Update existing prompt
        const updatedPrompt = {
          ...existing,
          promptText: prompt.promptText,
          variables: prompt.variables,
          modelCompatibility: prompt.modelCompatibility,
          updated_at: new Date().toISOString(),
          userModified: true
        };
        
        await promptService.savePrompt(updatedPrompt);
        return { imported: true, reason: 'overwrote existing' };
      } else {
        return { imported: false, reason: 'prompt already exists' };
      }
    } else {
      // Create new prompt
      const newPrompt = {
        ...prompt,
        id: generateId(),
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        userModified: true
      };
      
      await promptService.savePrompt(newPrompt);
      return { imported: true, reason: 'created new prompt' };
    }
  }
}

interface ExportData {
  version: string;
  exportDate: string;
  metadata: {
    source: string;
    promptCount: number;
    categories: string[];
  };
  prompts: Record<string, AIPrompt[]>;
}

interface ImportOptions {
  overwriteExisting: boolean;
  validateCompatibility: boolean;
  backupBeforeImport: boolean;
}

interface ImportResult {
  imported: number;
  skipped: number;
  errors: string[];
  warnings: string[];
}
```

## Database Operations

### Optimized Database Schema

```sql
-- Main prompts table with performance indexes
CREATE TABLE ai_prompts (
  id TEXT PRIMARY KEY,
  category TEXT NOT NULL,
  type TEXT NOT NULL,
  name TEXT NOT NULL,
  description TEXT,
  prompt_text TEXT NOT NULL,
  variables TEXT,                        -- JSON array: ["var1", "var2"]
  model_compatibility TEXT DEFAULT 'all', -- JSON array or 'all'
  is_default BOOLEAN DEFAULT 0,
  user_modified BOOLEAN DEFAULT 0,
  system_used BOOLEAN DEFAULT 0,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  
  -- Constraints
  UNIQUE(category, type),
  CHECK(category IN ('chat', 'analysis', 'speaker', 'validation')),
  CHECK(json_valid(variables) OR variables IS NULL),
  CHECK(json_valid(model_compatibility) OR model_compatibility = 'all')
);

-- Performance indexes
CREATE INDEX idx_ai_prompts_category ON ai_prompts(category);
CREATE INDEX idx_ai_prompts_type ON ai_prompts(type);
CREATE INDEX idx_ai_prompts_category_type ON ai_prompts(category, type);
CREATE INDEX idx_ai_prompts_system_used ON ai_prompts(system_used);
CREATE INDEX idx_ai_prompts_user_modified ON ai_prompts(user_modified);

-- Usage tracking table
CREATE TABLE prompt_usage (
  id TEXT PRIMARY KEY,
  prompt_id TEXT NOT NULL,
  service_name TEXT NOT NULL,
  method_name TEXT NOT NULL,
  usage_timestamp TEXT NOT NULL,
  execution_time_ms INTEGER,
  success BOOLEAN NOT NULL,
  error_message TEXT,
  
  FOREIGN KEY (prompt_id) REFERENCES ai_prompts(id),
  INDEX idx_prompt_usage_prompt_id (prompt_id),
  INDEX idx_prompt_usage_timestamp (usage_timestamp),
  INDEX idx_prompt_usage_service (service_name)
);

-- Prompt versions for change tracking
CREATE TABLE prompt_versions (
  id TEXT PRIMARY KEY,
  prompt_id TEXT NOT NULL,
  version_number INTEGER NOT NULL,
  prompt_text TEXT NOT NULL,
  changed_by TEXT NOT NULL,              -- 'user', 'system', 'import'
  change_reason TEXT,
  created_at TEXT NOT NULL,
  
  FOREIGN KEY (prompt_id) REFERENCES ai_prompts(id),
  UNIQUE(prompt_id, version_number),
  INDEX idx_prompt_versions_prompt_id (prompt_id)
);
```

### Efficient CRUD Operations

```typescript
class PromptDatabase {
  // Optimized retrieval with caching
  async getPrompt(category: string, type: string): Promise<AIPrompt | null> {
    try {
      const result = await window.electronAPI.database.get(
        `SELECT * FROM ai_prompts 
         WHERE category = ? AND type = ? 
         ORDER BY user_modified DESC, is_default ASC 
         LIMIT 1`,
        [category, type]
      );
      
      if (result) {
        return this.deserializePrompt(result);
      }
      
      return null;
    } catch (error) {
      console.error('Failed to get prompt:', error);
      return null;
    }
  }
  
  // Batch retrieval for categories
  async getPromptsByCategory(category: string): Promise<AIPrompt[]> {
    try {
      const results = await window.electronAPI.database.all(
        `SELECT * FROM ai_prompts 
         WHERE category = ? 
         ORDER BY system_used DESC, name ASC`,
        [category]
      );
      
      return results.map(result => this.deserializePrompt(result));
    } catch (error) {
      console.error('Failed to get prompts by category:', error);
      return [];
    }
  }
  
  // Efficient save with conflict resolution
  async savePrompt(prompt: AIPrompt): Promise<void> {
    try {
      const serializedPrompt = this.serializePrompt(prompt);
      
      // Upsert operation
      await window.electronAPI.database.run(
        `INSERT OR REPLACE INTO ai_prompts (
          id, category, type, name, description, prompt_text,
          variables, model_compatibility, is_default, user_modified,
          system_used, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          serializedPrompt.id,
          serializedPrompt.category,
          serializedPrompt.type,
          serializedPrompt.name,
          serializedPrompt.description,
          serializedPrompt.prompt_text,
          serializedPrompt.variables,
          serializedPrompt.model_compatibility,
          serializedPrompt.is_default ? 1 : 0,
          serializedPrompt.user_modified ? 1 : 0,
          serializedPrompt.system_used ? 1 : 0,
          serializedPrompt.created_at,
          serializedPrompt.updated_at
        ]
      );
      
      // Create version record
      await this.createVersionRecord(prompt, 'user_edit');
      
    } catch (error) {
      console.error('Failed to save prompt:', error);
      throw new Error(`Failed to save prompt: ${error.message}`);
    }
  }
  
  // Search with full-text support
  async searchPrompts(searchTerm: string, category?: string): Promise<AIPrompt[]> {
    let query = `
      SELECT * FROM ai_prompts 
      WHERE (name LIKE ? OR description LIKE ? OR prompt_text LIKE ?)
    `;
    const params = [`%${searchTerm}%`, `%${searchTerm}%`, `%${searchTerm}%`];
    
    if (category) {
      query += ` AND category = ?`;
      params.push(category);
    }
    
    query += ` ORDER BY system_used DESC, name ASC`;
    
    try {
      const results = await window.electronAPI.database.all(query, params);
      return results.map(result => this.deserializePrompt(result));
    } catch (error) {
      console.error('Failed to search prompts:', error);
      return [];
    }
  }
  
  // Usage tracking
  async recordUsage(
    promptId: string, 
    serviceName: string, 
    methodName: string,
    executionTimeMs: number,
    success: boolean,
    errorMessage?: string
  ): Promise<void> {
    try {
      await window.electronAPI.database.run(
        `INSERT INTO prompt_usage (
          id, prompt_id, service_name, method_name, usage_timestamp,
          execution_time_ms, success, error_message
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          generateId(),
          promptId,
          serviceName,
          methodName,
          new Date().toISOString(),
          executionTimeMs,
          success ? 1 : 0,
          errorMessage || null
        ]
      );
    } catch (error) {
      console.error('Failed to record prompt usage:', error);
    }
  }
  
  // Data serialization
  private serializePrompt(prompt: AIPrompt): any {
    return {
      ...prompt,
      variables: JSON.stringify(prompt.variables || []),
      model_compatibility: Array.isArray(prompt.modelCompatibility) 
        ? JSON.stringify(prompt.modelCompatibility)
        : prompt.modelCompatibility
    };
  }
  
  private deserializePrompt(row: any): AIPrompt {
    return {
      ...row,
      variables: row.variables ? JSON.parse(row.variables) : [],
      modelCompatibility: row.model_compatibility === 'all' 
        ? 'all' 
        : JSON.parse(row.model_compatibility),
      isDefault: Boolean(row.is_default),
      userModified: Boolean(row.user_modified),
      systemUsed: Boolean(row.system_used)
    };
  }
}
```

### IPC Communication Layer

```typescript
// Main process handlers
class PromptIPCHandlers {
  static register(): void {
    ipcMain.handle('ai-prompts-get-by-category', this.getByCategory);
    ipcMain.handle('ai-prompts-get', this.getPrompt);
    ipcMain.handle('ai-prompts-save', this.savePrompt);
    ipcMain.handle('ai-prompts-delete', this.deletePrompt);
    ipcMain.handle('ai-prompts-reset-to-default', this.resetToDefault);
    ipcMain.handle('ai-prompts-search', this.searchPrompts);
    ipcMain.handle('ai-prompts-export', this.exportPrompts);
    ipcMain.handle('ai-prompts-import', this.importPrompts);
  }
  
  private static async getByCategory(
    event: IpcMainInvokeEvent, 
    category: string
  ): Promise<AIPrompt[]> {
    try {
      return await promptDatabase.getPromptsByCategory(category);
    } catch (error) {
      console.error('IPC getByCategory failed:', error);
      return [];
    }
  }
  
  private static async getPrompt(
    event: IpcMainInvokeEvent,
    { category, type }: { category: string; type: string }
  ): Promise<AIPrompt | null> {
    try {
      return await promptDatabase.getPrompt(category, type);
    } catch (error) {
      console.error('IPC getPrompt failed:', error);
      return null;
    }
  }
  
  private static async savePrompt(
    event: IpcMainInvokeEvent,
    prompt: AIPrompt
  ): Promise<{ success: boolean; error?: string }> {
    try {
      await promptDatabase.savePrompt(prompt);
      return { success: true };
    } catch (error) {
      console.error('IPC savePrompt failed:', error);
      return { success: false, error: error.message };
    }
  }
  
  private static async resetToDefault(
    event: IpcMainInvokeEvent,
    { category, type }: { category: string; type: string }
  ): Promise<{ success: boolean; error?: string }> {
    try {
      // Delete user customization
      await promptDatabase.deleteUserPrompt(category, type);
      return { success: true };
    } catch (error) {
      console.error('IPC resetToDefault failed:', error);
      return { success: false, error: error.message };
    }
  }
}

// Renderer process API
declare global {
  interface Window {
    electronAPI: {
      aiPrompts: {
        getByCategory(category: string): Promise<AIPrompt[]>;
        get(params: { category: string; type: string }): Promise<AIPrompt | null>;
        save(prompt: AIPrompt): Promise<{ success: boolean; error?: string }>;
        delete(id: string): Promise<{ success: boolean; error?: string }>;
        resetToDefault(params: { category: string; type: string }): Promise<{ success: boolean; error?: string }>;
        search(searchTerm: string, category?: string): Promise<AIPrompt[]>;
        export(category?: string): Promise<ExportData>;
        import(data: ExportData, options: ImportOptions): Promise<ImportResult>;
      };
    };
  }
}
```

## Error Handling & Fallbacks

### Multi-Layer Fallback System

The prompt system implements a comprehensive error handling strategy with multiple fallback layers:

```typescript
class PromptFallbackManager {
  /**
   * Primary method for getting processed prompts with full fallback chain
   */
  async getProcessedPromptWithFallbacks(
    category: string,
    type: string,
    variables: Record<string, string>
  ): Promise<string> {
    const fallbackChain = [
      () => this.tryUserCustomPrompt(category, type, variables),
      () => this.tryDefaultPrompt(category, type, variables),
      () => this.tryCategoryFallback(category, variables),
      () => this.tryEmergencyFallback(variables)
    ];
    
    for (const fallbackMethod of fallbackChain) {
      try {
        const result = await fallbackMethod();
        if (result) {
          return result;
        }
      } catch (error) {
        console.warn(`Fallback method failed:`, error);
        continue; // Try next fallback
      }
    }
    
    // Ultimate fallback - should never reach here
    return this.getUltimateFallback(variables);
  }
  
  /**
   * Level 1: Try user-customized prompt
   */
  private async tryUserCustomPrompt(
    category: string,
    type: string,
    variables: Record<string, string>
  ): Promise<string | null> {
    try {
      const prompt = await window.electronAPI.aiPrompts.get({ category, type });
      if (prompt && prompt.userModified) {
        return this.processTemplate(prompt.promptText, variables);
      }
      return null;
    } catch (error) {
      console.warn('User custom prompt failed:', error);
      return null;
    }
  }
  
  /**
   * Level 2: Try default system prompt
   */
  private async tryDefaultPrompt(
    category: string,
    type: string,
    variables: Record<string, string>
  ): Promise<string | null> {
    try {
      const defaultPrompt = DefaultPromptRegistry.getDefault(category, type);
      if (defaultPrompt) {
        return this.processTemplate(defaultPrompt.promptText, variables);
      }
      return null;
    } catch (error) {
      console.warn('Default prompt failed:', error);
      return null;
    }
  }
  
  /**
   * Level 3: Try category-level fallback
   */
  private async tryCategoryFallback(
    category: string,
    variables: Record<string, string>
  ): Promise<string | null> {
    const categoryFallbacks = {
      chat: `Answer this question about the content: {message}\n\nContent: {context}`,
      analysis: `Analyze this content and provide insights: {transcript}`,
      speaker: `Analyze the speakers in this content: {transcript}`,
      validation: `Review and correct this text: {transcript}`
    };
    
    const fallbackTemplate = categoryFallbacks[category];
    if (fallbackTemplate) {
      return this.processTemplate(fallbackTemplate, variables);
    }
    
    return null;
  }
  
  /**
   * Level 4: Emergency fallback with minimal template
   */
  private async tryEmergencyFallback(
    variables: Record<string, string>
  ): Promise<string | null> {
    const emergencyTemplate = `Please process this content: {transcript}{context}{message}`;
    return this.processTemplate(emergencyTemplate, variables);
  }
  
  /**
   * Ultimate fallback - should never fail
   */
  private getUltimateFallback(variables: Record<string, string>): string {
    const content = Object.values(variables).filter(Boolean).join('\n\n');
    return `Please analyze and respond to the following content:\n\n${content}`;
  }
  
  /**
   * Template processing with error handling
   */
  private processTemplate(
    template: string,
    variables: Record<string, string>
  ): string {
    try {
      let result = template;
      
      // Replace all variables
      for (const [key, value] of Object.entries(variables)) {
        if (value) {
          const regex = new RegExp(`\\{${key}\\}`, 'g');
          result = result.replace(regex, value);
        }
      }
      
      // Remove unreplaced variables
      result = result.replace(/\{[^}]+\}/g, '');
      
      // Clean up extra whitespace
      result = result.replace(/\n\s*\n\s*\n/g, '\n\n').trim();
      
      return result;
    } catch (error) {
      console.error('Template processing failed:', error);
      // Return raw template as last resort
      return template;
    }
  }
}
```

### Error Recovery Strategies

```typescript
class PromptErrorRecovery {
  async handlePromptFailure(
    category: string,
    type: string,
    error: Error,
    context: ErrorContext
  ): Promise<RecoveryAction> {
    const errorType = this.classifyError(error);
    
    switch (errorType) {
      case 'database_error':
        return await this.handleDatabaseError(category, type, error, context);
        
      case 'template_error':
        return await this.handleTemplateError(category, type, error, context);
        
      case 'validation_error':
        return await this.handleValidationError(category, type, error, context);
        
      case 'network_error':
        return await this.handleNetworkError(category, type, error, context);
        
      default:
        return await this.handleUnknownError(category, type, error, context);
    }
  }
  
  private async handleDatabaseError(
    category: string,
    type: string,
    error: Error,
    context: ErrorContext
  ): Promise<RecoveryAction> {
    // Try to use in-memory defaults
    const defaultPrompt = DefaultPromptRegistry.getDefault(category, type);
    if (defaultPrompt) {
      return {
        action: 'use_default',
        prompt: defaultPrompt.promptText,
        message: 'Database unavailable, using default prompt',
        severity: 'warning'
      };
    }
    
    return {
      action: 'use_fallback',
      prompt: this.getCategoryFallback(category),
      message: 'Database and defaults unavailable, using emergency fallback',
      severity: 'error'
    };
  }
  
  private async handleTemplateError(
    category: string,
    type: string,
    error: Error,
    context: ErrorContext
  ): Promise<RecoveryAction> {
    // Try to fix common template issues
    const fixedTemplate = this.attemptTemplateFix(context.originalTemplate);
    if (fixedTemplate) {
      return {
        action: 'use_fixed_template',
        prompt: fixedTemplate,
        message: 'Template had issues, used corrected version',
        severity: 'warning'
      };
    }
    
    // Fall back to simpler template
    return {
      action: 'use_simple_template',
      prompt: this.getSimpleTemplate(category, context.variables),
      message: 'Template corrupted, using simplified version',
      severity: 'error'
    };
  }
  
  private attemptTemplateFix(template: string): string | null {
    try {
      // Fix common issues
      let fixed = template;
      
      // Fix unclosed braces
      const openBraces = (fixed.match(/\{/g) || []).length;
      const closeBraces = (fixed.match(/\}/g) || []).length;
      if (openBraces > closeBraces) {
        fixed += '}';
      }
      
      // Remove invalid variable patterns
      fixed = fixed.replace(/\{[^a-zA-Z_][^}]*\}/g, '');
      
      // Validate the fix
      const variables = this.extractVariables(fixed);
      if (variables.length > 0 && variables.every(v => /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(v))) {
        return fixed;
      }
      
      return null;
    } catch (error) {
      console.warn('Template fix attempt failed:', error);
      return null;
    }
  }
  
  private getSimpleTemplate(category: string, variables: Record<string, string>): string {
    const hasTranscript = variables.transcript || variables.content;
    const hasMessage = variables.message || variables.question;
    
    switch (category) {
      case 'chat':
        return hasTranscript && hasMessage
          ? `Based on this content: {transcript}\n\nPlease answer: {message}`
          : `Please respond to: {message}`;
          
      case 'analysis':
        return hasTranscript
          ? `Please analyze: {transcript}`
          : `Please analyze the provided content.`;
          
      case 'speaker':
        return hasTranscript
          ? `Identify speakers in: {transcript}`
          : `Please identify speakers in the content.`;
          
      case 'validation':
        return hasTranscript
          ? `Please review and correct: {transcript}`
          : `Please review the provided content.`;
          
      default:
        return `Please process: ${Object.keys(variables).map(k => `{${k}}`).join(' ')}`;
    }
  }
}
```

### User-Facing Error Handling

```typescript
class PromptErrorUI {
  static showErrorToUser(error: PromptError, context: ErrorContext): void {
    const errorMessage = this.getErrorMessage(error);
    const recoveryOptions = this.getRecoveryOptions(error, context);
    
    // Show notification to user
    this.showNotification({
      type: error.severity,
      title: 'Prompt System Issue',
      message: errorMessage,
      actions: recoveryOptions,
      persistent: error.severity === 'error'
    });
  }
  
  private static getErrorMessage(error: PromptError): string {
    switch (error.type) {
      case 'database_error':
        return 'Unable to access prompt database. Using default prompts.';
        
      case 'template_error':
        return 'Prompt template has errors. Using simplified version.';
        
      case 'validation_error':
        return 'Prompt validation failed. Check variables and syntax.';
        
      case 'network_error':
        return 'Network error accessing prompts. Using cached version.';
        
      default:
        return 'Prompt system encountered an issue. Functionality may be limited.';
    }
  }
  
  private static getRecoveryOptions(
    error: PromptError, 
    context: ErrorContext
  ): NotificationAction[] {
    const options: NotificationAction[] = [];
    
    if (error.type === 'template_error' && context.promptId) {
      options.push({
        label: 'Reset to Default',
        action: () => this.resetPromptToDefault(context.promptId),
        style: 'primary'
      });
    }
    
    if (error.type === 'database_error') {
      options.push({
        label: 'Retry',
        action: () => this.retryDatabaseConnection(),
        style: 'primary'
      });
    }
    
    options.push({
      label: 'View Details',
      action: () => this.showErrorDetails(error, context),
      style: 'secondary'
    });
    
    return options;
  }
  
  private static async resetPromptToDefault(promptId: string): Promise<void> {
    try {
      await window.electronAPI.aiPrompts.resetToDefault(promptId);
      this.showNotification({
        type: 'success',
        title: 'Prompt Reset',
        message: 'Prompt has been reset to default version.'
      });
    } catch (error) {
      this.showNotification({
        type: 'error',
        title: 'Reset Failed',
        message: 'Unable to reset prompt. Please try again.'
      });
    }
  }
}
```

## API Reference

### Core Service API

```typescript
interface PromptServiceAPI {
  // Primary processing method
  getProcessedPrompt(
    category: string,
    type: string,
    variables: Record<string, string>
  ): Promise<string>;
  
  // CRUD operations
  getPrompt(category: string, type: string): Promise<AIPrompt | null>;
  getPromptsByCategory(category: string): Promise<AIPrompt[]>;
  getAllPrompts(): Promise<AIPrompt[]>;
  savePrompt(prompt: AIPrompt): Promise<void>;
  deletePrompt(id: string): Promise<void>;
  
  // Default management
  getDefaultPrompt(category: string, type: string): AIPrompt | null;
  resetToDefault(category: string, type: string): Promise<void>;
  
  // Template processing
  replaceVariables(template: string, variables: Record<string, string>): string;
  extractVariables(template: string): string[];
  validateTemplate(template: string): TemplateValidation;
  
  // Search and filtering
  searchPrompts(query: string, category?: string): Promise<AIPrompt[]>;
  getSystemUsedPrompts(): Promise<AIPrompt[]>;
  getCustomizedPrompts(): Promise<AIPrompt[]>;
  
  // Import/Export
  exportPrompts(category?: string): Promise<ExportData>;
  importPrompts(data: ExportData, options: ImportOptions): Promise<ImportResult>;
  
  // Utility methods
  estimateTokens(text: string): number;
  validatePrompt(prompt: AIPrompt): ValidationResult;
  getUsageStatistics(category?: string, type?: string): Promise<UsageStatistics>;
}
```

### Data Types

```typescript
interface AIPrompt {
  id: string;
  category: 'chat' | 'analysis' | 'speaker' | 'validation';
  type: string;
  name: string;
  description?: string;
  promptText: string;
  variables: string[];
  modelCompatibility: string[] | 'all';
  isDefault: boolean;
  userModified: boolean;
  systemUsed: boolean;
  created_at: string;
  updated_at: string;
}

interface TemplateValidation {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  variables: string[];
  estimatedTokens: number;
}

interface ValidationResult {
  isValid: boolean;
  errors: ValidationError[];
  warnings: ValidationWarning[];
  compatibility: CompatibilityResult;
}

interface UsageStatistics {
  totalUsage: number;
  lastUsed?: string;
  usageFrequency: 'high' | 'medium' | 'low' | 'none';
  primaryServices: string[];
  averageExecutionTime: number;
}

interface ExportData {
  version: string;
  exportDate: string;
  metadata: {
    source: string;
    promptCount: number;
    categories: string[];
  };
  prompts: Record<string, AIPrompt[]>;
}

interface ImportOptions {
  overwriteExisting: boolean;
  validateCompatibility: boolean;
  backupBeforeImport: boolean;
  importOnlyCategory?: string;
}

interface ImportResult {
  imported: number;
  skipped: number;
  errors: string[];
  warnings: string[];
  backupPath?: string;
}
```

### Event System

```typescript
interface PromptEventEmitter {
  // Event subscription
  on(event: 'prompt_changed', callback: (category: string, type: string) => void): void;
  on(event: 'prompt_deleted', callback: (category: string, type: string) => void): void;
  on(event: 'prompt_reset', callback: (category: string, type: string) => void): void;
  on(event: 'import_completed', callback: (result: ImportResult) => void): void;
  on(event: 'validation_failed', callback: (prompt: AIPrompt, errors: string[]) => void): void;
  
  // Event emission
  emit(event: string, ...args: any[]): void;
  
  // Event removal
  off(event: string, callback: Function): void;
  removeAllListeners(event?: string): void;
}

// Usage example
promptService.on('prompt_changed', (category, type) => {
  console.log(`Prompt changed: ${category}:${type}`);
  // Invalidate caches, notify other services, etc.
});
```

## Implementation Patterns

### 1. Service Layer Pattern

```typescript
// Clear separation of concerns
class PromptService {
  // Business logic layer
  async getProcessedPrompt(...): Promise<string> { /* ... */ }
}

class PromptDatabase {
  // Data access layer
  async getPrompt(...): Promise<AIPrompt | null> { /* ... */ }
}

class PromptCache {
  // Caching layer
  get(key: string): AIPrompt | null { /* ... */ }
}
```

### 2. Template Method Pattern

```typescript
abstract class PromptProcessor {
  // Template method defining the algorithm
  async processPrompt(category: string, type: string, variables: Record<string, string>): Promise<string> {
    const prompt = await this.retrievePrompt(category, type);
    const validated = this.validatePrompt(prompt, variables);
    const processed = this.applyVariables(validated, variables);
    return this.postProcess(processed);
  }
  
  // Abstract methods implemented by subclasses
  protected abstract retrievePrompt(category: string, type: string): Promise<AIPrompt>;
  protected abstract validatePrompt(prompt: AIPrompt, variables: Record<string, string>): AIPrompt;
  protected abstract applyVariables(prompt: AIPrompt, variables: Record<string, string>): string;
  protected abstract postProcess(processed: string): string;
}
```

### 3. Chain of Responsibility Pattern

```typescript
abstract class FallbackHandler {
  protected nextHandler?: FallbackHandler;
  
  setNext(handler: FallbackHandler): FallbackHandler {
    this.nextHandler = handler;
    return handler;
  }
  
  async handle(category: string, type: string, variables: Record<string, string>): Promise<string | null> {
    const result = await this.process(category, type, variables);
    if (result) {
      return result;
    }
    
    if (this.nextHandler) {
      return this.nextHandler.handle(category, type, variables);
    }
    
    return null;
  }
  
  protected abstract process(category: string, type: string, variables: Record<string, string>): Promise<string | null>;
}

// Specific handlers
class UserPromptHandler extends FallbackHandler {
  protected async process(category: string, type: string, variables: Record<string, string>): Promise<string | null> {
    // Try user-customized prompt
  }
}

class DefaultPromptHandler extends FallbackHandler {
  protected async process(category: string, type: string, variables: Record<string, string>): Promise<string | null> {
    // Try default prompt
  }
}
```

### 4. Observer Pattern

```typescript
interface PromptObserver {
  onPromptChanged(category: string, type: string): void;
  onPromptDeleted(category: string, type: string): void;
}

class PromptSubject {
  private observers: PromptObserver[] = [];
  
  subscribe(observer: PromptObserver): void {
    this.observers.push(observer);
  }
  
  unsubscribe(observer: PromptObserver): void {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }
  
  notify(event: string, ...args: any[]): void {
    this.observers.forEach(observer => {
      if (event === 'changed' && observer.onPromptChanged) {
        observer.onPromptChanged(...args);
      } else if (event === 'deleted' && observer.onPromptDeleted) {
        observer.onPromptDeleted(...args);
      }
    });
  }
}
```

## Best Practices

### 1. Template Design

```typescript
// âœ… Good: Clear variable naming
const goodTemplate = `Analyze this transcript titled "{title}" and provide insights about {focus_area}.

Content: {transcript}

Please format your response as JSON with the following structure:
{
  "summary": "Brief summary",
  "insights": ["insight1", "insight2"],
  "confidence": "high|medium|low"
}`;

// âŒ Bad: Unclear variables and complex logic
const badTemplate = `Process {data} using {method} and return {format} with {options} if {condition} else {fallback}`;
```

### 2. Error Handling

```typescript
// âœ… Good: Comprehensive error handling with fallbacks
async getProcessedPrompt(category: string, type: string, variables: Record<string, string>): Promise<string> {
  try {
    const prompt = await this.getPrompt(category, type);
    if (!prompt) {
      return this.getDefaultPrompt(category, type, variables);
    }
    return this.replaceVariables(prompt.promptText, variables);
  } catch (error) {
    console.warn('Prompt processing failed, using fallback:', error);
    return this.getFallbackPrompt(category, variables);
  }
}

// âŒ Bad: No error handling
async getProcessedPrompt(category: string, type: string, variables: Record<string, string>): Promise<string> {
  const prompt = await this.getPrompt(category, type);
  return this.replaceVariables(prompt.promptText, variables);
}
```

### 3. Variable Management

```typescript
// âœ… Good: Validate variables before processing
private validateVariables(template: string, variables: Record<string, string>): ValidationResult {
  const requiredVars = this.extractVariables(template);
  const providedVars = Object.keys(variables);
  const missingVars = requiredVars.filter(v => !providedVars.includes(v));
  
  return {
    isValid: missingVars.length === 0,
    errors: missingVars.map(v => `Missing required variable: {${v}}`),
    warnings: this.checkVariableQuality(variables)
  };
}

// âŒ Bad: Process without validation
private processTemplate(template: string, variables: Record<string, string>): string {
  return template.replace(/\{(\w+)\}/g, (match, varName) => variables[varName] || match);
}
```

### 4. Performance Optimization

```typescript
// âœ… Good: Cache frequently used prompts
class PromptCache {
  private cache = new Map<string, { prompt: AIPrompt; timestamp: number }>();
  private readonly TTL = 5 * 60 * 1000; // 5 minutes
  
  get(category: string, type: string): AIPrompt | null {
    const key = `${category}:${type}`;
    const cached = this.cache.get(key);
    
    if (cached && Date.now() - cached.timestamp < this.TTL) {
      return cached.prompt;
    }
    
    this.cache.delete(key);
    return null;
  }
  
  set(category: string, type: string, prompt: AIPrompt): void {
    const key = `${category}:${type}`;
    this.cache.set(key, { prompt, timestamp: Date.now() });
  }
}

// âŒ Bad: No caching, repeated database calls
async getPrompt(category: string, type: string): Promise<AIPrompt | null> {
  return await database.getPrompt(category, type);
}
```

### 5. Configuration Management

```typescript
// âœ… Good: Centralized configuration with validation
interface PromptSystemConfig {
  enableFallbacks: boolean;
  cacheEnabled: boolean;
  cacheTTL: number;
  maxTemplateSize: number;
  enableUsageTracking: boolean;
}

class PromptConfigManager {
  private config: PromptSystemConfig;
  
  updateConfig(newConfig: Partial<PromptSystemConfig>): void {
    const validatedConfig = this.validateConfig({ ...this.config, ...newConfig });
    this.config = validatedConfig;
    this.notifyConfigChange();
  }
  
  private validateConfig(config: PromptSystemConfig): PromptSystemConfig {
    if (config.cacheTTL < 0) {
      throw new Error('Cache TTL must be positive');
    }
    if (config.maxTemplateSize < 100) {
      throw new Error('Max template size too small');
    }
    return config;
  }
}

// âŒ Bad: Configuration scattered throughout code
const CACHE_ENABLED = true;
const MAX_SIZE = 10000;
const ENABLE_TRACKING = false;
```

---

This AI Prompt Management System provides a robust, scalable foundation for implementing configurable AI interactions in any application. The modular design, comprehensive error handling, and extensive customization options make it suitable for a wide range of AI-powered applications requiring dynamic prompt management.